{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/04/20/discovery-agent","webpackCompilationHash":"5922713c92655645bc49","result":{"data":{"markdownRemark":{"id":"5871def0-8b09-5bc9-9ebe-feefb4baefe8","excerpt":"Update 2018-02-14, since Amazon has introduced a feature to extract meta data at runtime in a container the discovery agent described in…","html":"<p><em>Update 2018-02-14, since Amazon has introduced a feature to extract meta data at runtime in a container the discovery agent described in this post becomes obsolete for the ECS case, see more <a href=\"/2018/02/14/service-discovery\">this</a> post for more details.</em></p>\n<p>This post describes a solution for implementing the discovery of the unknown exposed port by a <a href=\"https://www.docker.com/\">Docker</a> container. A specific situation where the problem occurs is when you deploy <a href=\"http://projects.spring.io/spring-cloud/\">Spring Cloud</a> micro services as <a href=\"https://aws.amazon.com/ecs/\">Amazon ECS</a> services to the cloud.</p>\n<h3 id=\"the-problem\"><a href=\"#the-problem\" aria-label=\"the problem permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem</h3>\n<p>Setting up a micro services architecture requires that there is a way services can find each other. Spring Cloud provides a services discovery service out of the box: Eureka. Services running in the micro services landscape are responsible to register themselves to the discovery service. Then, any service running in the micro services landscape can locate them based on their name. Deploying those services to a docker based cloud, such as AWS, does however create some difficulties.</p>\n<p>A service running in a container does not know the external exposed port. The port map can be fixed, for example by mapping the external port on the same port as the internal one but this will eventually cause port conflicts. Besides that, you are not able to scale the container on the same host. Therefore, it make sense to use automatic port assignment. But in that case, services must be able to discover the port, assigned by docker, for registration.</p>\n<p>Running micro services in docker containers on AWS ECS looks as follows.</p>\n<a href=\"#\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 441px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.17233560090703%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACY0lEQVQ4y4VT+0/TUBTuf+cf5g8mijFRJJFEf9HoIDpYBppAlDD3CgKhMPag6wZ7wrZuXZ/0dT9P7+0WNCY2/XpPz+Prd8+5lRBfjNFNiO37LqJZCZFWBjNOEOnHHKH+C9H8GDBP4YzLsG4LgH1JdaGoY/wJaUEoSMkOB3DqKUy/P0EwLeO6kkGvvoNuLQtVTsO5y6FT/wZF3qaPE2EUAP8iZIkjdAdw70idLoNZVTDzEr5+Dlc7RUR2DDg1rs7RLqg2+kvhUp1weJ4HbTp7+FH4fgBNmwqfcCGMGEajcZLHlpAWScvEMIRlWcvExfqnjyU++2HHEkLOHHEs5NuOkySSDxHvk2XOsbySGuGL60KxxltmFvXEqlBfqrw3RukN3KEs6twOn2wwo2nbFTiVFNzKpogFBo+FetxbGf7wEGZxjRQaRxhe7aJ59pmOQg7q/gqGjZxQ4rZg9vb5dO9aexidf8J1+X1COEcwyfFT0KlmMWt9RfNglQhjdcYZwrnMJ9dWDjEdNwWhNxDqadpw65jenuCmdSRiEfWPVMOu8t2FRgUtpQDJoa2b1DjXj+B4IfyA4Z5ge4zeKdenWCBWCoPSyM9g3kPAE7DjOMWkk4MfUDaeodT0ULxyUGjYKDYcbsfI103ka8YSxYaFfMOF0h2i21fR6bc51HYDsjqCtPf2FZTHj7BZ0pHKa9jITwga2RNsFmdY36njdVrG6pczrG2dU2yMDz91DLunmKlpDGppTFT6ky5SOL6sQXqZ7eHF1jVWMn083+79H5kenm718fGghWxRwXZeQaagYLfcxLu9G/wGweDC6OBd6mEAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <picture>\n        <source srcset=\"/static/110c23341dfbfef4c9a08632a2d31764/cc182/ecs1.webp 148w,\n/static/110c23341dfbfef4c9a08632a2d31764/f7e40/ecs1.webp 295w,\n/static/110c23341dfbfef4c9a08632a2d31764/efddf/ecs1.webp 441w\" sizes=\"(max-width: 441px) 100vw, 441px\" type=\"image/webp\">\n        <source srcset=\"/static/110c23341dfbfef4c9a08632a2d31764/cf440/ecs1.png 148w,\n/static/110c23341dfbfef4c9a08632a2d31764/d2d38/ecs1.png 295w,\n/static/110c23341dfbfef4c9a08632a2d31764/98017/ecs1.png 441w\" sizes=\"(max-width: 441px) 100vw, 441px\" type=\"image/png\">\n        <img class=\"gatsby-resp-image-image\" src=\"/static/110c23341dfbfef4c9a08632a2d31764/98017/ecs1.png\" alt=\"ECS\" title=\"ECS\" loading=\"lazy\">\n      </picture>\n    </span>\n</a>\n<p>Each micro service is defined as task which will run as service (a docker container). The docker container runs on a Amazon EC2 instance that also runs docker agent to manage the cluster. Unfortunately, the agent has no API to lookup the exposed port.</p>\n<h3 id=\"solution\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h3>\n<p>To lookup the exposed port an extra agent is added to the EC2 instance. The <a href=\"https://github.com/npalm/docker-discovery-agent\">discovery agent</a> uses an API to discover the port for a given container id, internal port and protocol. The only drawback is that the discovery agent needs access to the docker socket which is a potential security risk.</p>\n<a href=\"#\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 47.324414715719065%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACKElEQVQoz61QS2sTURgdO/XZhRtFXViCLaKiUMGtoG7cuekPEFQo1E0WQkURWlTETaXS0qIVKlg3iovgi0TzaDJJJ4mZPJqYaGaSTFPyfreTTF7He4UUpFs/ONzvfvfcc+85DLOzdlEYPy7soRu15HqKmh3NtFmt5x1dJWPrKFmu2yry7VqaQ6fs8lKe9s44g6p7h1gfQT/F1P2xfXRQTtuftGI6qOuGfDFpKWei+lpG1FfqWa5YkM2qWlhdpbypx/cY8si20EGCYwSHqCgABoiz9MBjWDji9n49C1SOoxs8IXBvzwHBITQEDSBqPr2fOaV7N8OiI/RtfLjL9gSPEpwh0JwcHmSZ/1WXL16gdplWib/eLvHP2hX3IyXw5nlqZfY0Wj9HyGxZKThfNiXdsuKcv0Gc7G7k7HOtsmuRZPyiIbya/Udwfnri7+/IRZ7YAZoBoGaF/8v0NSA8CiTRqbiJTgCSbVFHmr1oeAHVBzQ8qIs69PKj2R0eGDhAVxabvtF2LTQJJTIhSfykIxgdaiobg1C8WnRCY9WcU+tLxa50AVathG52lV+3G9XweCSycqsnSPM7TwSH6UCIFh5KcuyHGJfMcjJhictR4fd6VjCtbVmN/rLNHNqy+k3fnJFwNBBLyhzhWaWE6FhLlD9v22XZfvbqpZH9tP/O+/XtzSAyCSvySQdSMTNEWcRrUw5LhgSWjCk45h4gxJtRynqQk22Ex8HiCXf+AFIpa2+58wjGAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <picture>\n        <source srcset=\"/static/79183530a7cd706df5ac94b8fa05bc07/cc182/ecs2.webp 148w,\n/static/79183530a7cd706df5ac94b8fa05bc07/f7e40/ecs2.webp 295w,\n/static/79183530a7cd706df5ac94b8fa05bc07/1a2f4/ecs2.webp 590w,\n/static/79183530a7cd706df5ac94b8fa05bc07/5eb91/ecs2.webp 598w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/webp\">\n        <source srcset=\"/static/79183530a7cd706df5ac94b8fa05bc07/cf440/ecs2.png 148w,\n/static/79183530a7cd706df5ac94b8fa05bc07/d2d38/ecs2.png 295w,\n/static/79183530a7cd706df5ac94b8fa05bc07/b9e4f/ecs2.png 590w,\n/static/79183530a7cd706df5ac94b8fa05bc07/16bf3/ecs2.png 598w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/png\">\n        <img class=\"gatsby-resp-image-image\" src=\"/static/79183530a7cd706df5ac94b8fa05bc07/b9e4f/ecs2.png\" alt=\"ECS\" title=\"ECS\" loading=\"lazy\">\n      </picture>\n    </span>\n</a>\n<p>Let’s explain the working of the discovery agent by example: First we have to start the agent as a docker container.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -d -v /var/run/docker.sock:/var/run/docker.sock \\\n  --name docker-discovery-agent -p 5555:8080 npalm/docker-discovery-agent:1.0.0</code></pre></div>\n<p>Now the agent is running, it can be tested. For testing we start another container, remember the problem is that we need to find the exposed port from <strong>within</strong> a container. The local ip address will be added as extra host to the container. The test container is just a linux (CentOS) container containing the tool <code class=\"language-text\">curl</code> and for which port 80 is exposed to a random port.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export DOCKERHOST=$(ifconfig | grep -E &quot;([0-9]{1,3}\\.){3}[0-9]{1,3}&quot; | \\\n  grep -v 127.0.0.1 | awk &#39;{ print $2 }&#39; | cut -f2 -d: | head -n1)\ndocker run -it -p 80 --add-host=&quot;dockerhost:$(DOCKERHOST)&quot; --rm centos /bin/bash</code></pre></div>\n<p>We are now in the shell of the CentOS container, the host file contains a DNS entry that points to the host. First, we have to search for the id of the current container.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CONTAINER_ID=$(cat /proc/self/cgroup | grep &quot;cpu:/&quot; | sed &#39;s/\\([0-9]\\):cpu:\\/docker\\///g&#39;)</code></pre></div>\n<p>Then, we ask the discovery agent for our external mapped port by sending the container id and the internal port.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl &quot;http://dockerhost:5555/container/${CONTAINER_ID}/portbinding?port=80&amp;protocol=tcp&quot;</code></pre></div>\n<p>The result is a JSON string container with the hostIp and hostPort, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n\t&quot;HostIp&quot;: &quot;0.0.0.0&quot;,\n\t&quot;HostPort&quot;: &quot;32779&quot;\n}</code></pre></div>\n<p>Alternative to passing the host ip address, it is possible to register a static ip address and use this to find the dicovery agent.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sudo ifconfig lo0 alias 172.16.123.1</code></pre></div>\n<p>Now we can discover the exposed port, let’s give some direction on how this can be combined with Spring Cloud on ECS. First deploy Eureka (service discover) as container. Register an ALB (internal) to the service. Now we have an endpoint that we can use to inject the service that needs to register itself. Next create a spring service that is aware of discovery. Before the services can be started, the exposed port needs to be found. Add the snippet below to the start script to start the services in the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#!/bin/bash\nexport DOCKER_HOST=$(curl -s 169.254.169.254/latest/meta-data/local-ipv4)\nexport CONTAINER_ID=$(cat /proc/self/cgroup | grep &quot;cpu:/&quot; | \\\n  sed &#39;s/\\([0-9]\\):cpu:\\/docker\\///g&#39;)\nexport NETWORK_BINDING=\\\n  $(curl &quot;http://${DOCKER_HOST}:5555/container/${CONTAINER_ID}/portbinding?port=8080&amp;protocol=tcp&quot;)\nexport EXPOSED_PORT=$(echo ${NETWORK_BINDING} | jq -c &#39;.[0].HostPort&#39; | \\\n  sed -e &#39;s/^&quot;//&#39;  -e &#39;s/&quot;$//&#39;)\n\nexec java -jar /service.jar</code></pre></div>\n<p>The last step is to update the <code class=\"language-text\">application.yml</code> and add a few lines to force the ip address and port during service registration.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eureka:\n  client:\n    serviceUrl:\n      defaultZone: ${EUREKA_URL} // Needs to be injected as environment variable\n  instance:\n    preferIpAddress: true\n    ip-address: ${DOCKER_HOST}\n    non-secure-port: ${EXPOSED_PORT}</code></pre></div>\n<h3 id=\"alternatives\"><a href=\"#alternatives\" aria-label=\"alternatives permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Alternatives</h3>\n<p>Discovery of the unknown exposed port is a highly discussed topic and there are many alternative solutions, Please see <a href=\"https://github.com/docker/docker/issues/3778\">docker issue</a>, which is a good starting point for alternatives. The following alternatives came to my mind:</p>\n<ul>\n<li>Same approach, but run the discovery service directly on the host.</li>\n<li>Implement the discovery capability in each servie as a library, but the drawback is that all the services need the docker socket.</li>\n<li>Choose another discovery mechanism for example based on ALB.</li>\n<li>Switch to <a href=\"https://github.com/hashicorp/consul\">Consul</a> in combination with a <a href=\"https://github.com/gliderlabs/registrator\">registrator</a></li>\n</ul>","frontmatter":{"title":"Discover the exposed port","subtitle":"Enabling discovery for Spring Cloud on AWS ECS","date":"2017-04-20","slug":"2019/04/20/discovery-agent","language":null,"tags":["docker","aws","spring"],"authors":["niek"],"comments":null,"cover":{"publicURL":"/static/silly-walk-this-way-dommeltunnel-fa8b1ac5e32852678cbc2c78aa5d244d.png"},"coverLink":null,"coverDescription":null,"imageTw":{"publicURL":"/static/2019-04-20-discovery-agent-tw-d4a1fef152bac0814c246179261ca3c6.png"},"imageFb":{"publicURL":"/static/2019-04-20-discovery-agent-fb-36d76c188d5a19fe2c90f56d755a1ec7.png"},"asciinema":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2019/04/20/discovery-agent","previous":null,"next":{"frontmatter":{"title":"Periodic builds in GitLab","slug":"2017/04/21/gitlab-perodic-build","type":"post","tags":["gitlab","docker"],"authors":["niek"]}}}}}