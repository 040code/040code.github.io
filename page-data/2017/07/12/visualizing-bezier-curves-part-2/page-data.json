{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017/07/12/visualizing-bezier-curves-part-2","webpackCompilationHash":"5922713c92655645bc49","result":{"data":{"markdownRemark":{"id":"44a7a33f-8a59-5b60-9716-de70139107c6","excerpt":"In my previous post I described how to visualise simple Bézier curves. I chose  as implementation language. Unfortunately I had to ask you…","html":"<p>In my <a href=\"https://040code.github.io/2017/07/01/bezier-in-clojure/\">previous post</a> I described how to visualise simple Bézier curves. I chose <code class=\"language-text\">Clojure</code> as implementation language. Unfortunately I had to ask you to jump through a couple of hoops in order to code along: installing leiningen, installing and configuring the lein-try plugin and maybe even installing the JVM.</p>\n<p>This post will be easier for you - at least in terms of setup. You won’t have to leave your browser and can experiment with <code class=\"language-text\">Clojure(Script)</code> right here on this page!</p>\n<h2 id=\"no-setup\"><a href=\"#no-setup\" aria-label=\"no setup permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NO Setup</h2>\n<p>In this post we’re going to use the very useful <a href=\"https://github.com/viebel/klipse\">klipse plugin</a>. Klipse is a client-side code evaluator pluggable on any web page. It can evaluate <code class=\"language-text\">Clojure</code>, <code class=\"language-text\">ClojureScript</code>, ruby, javascript, python, scheme, es2017, jsx, brainfuck, c++, reagent and probably much more languages in the near future. It’s like <a href=\"https://jsfiddle.net\">jsfiddle</a> on steroids, right here in the 040code blog.</p>\n<p>Let’s start with a very simple Klipse demonstration. I’m going to <code class=\"language-text\">map</code> the <code class=\"language-text\">inc</code>(rement) function over the numbers 1, 2 and 3. The result will not surprise you:</p>\n<pre><code class=\"language-klipse\">(map inc [1 2 3])</code></pre>\n<p>What might surprise you though, is that <strong>you can change the code in the klipse evaluator</strong> and see the results immediately in your browser. So for instance change <code class=\"language-text\">(map inc [1 2 3])</code> into <code class=\"language-text\">(map inc [41 999 2])</code> and be amazed. Or change it into something completely different like <code class=\"language-text\">(filter even? (range 10))</code>.</p>\n<p>Defining functions and calling them? No problem:</p>\n<pre>\n  <code class=\"language-klipse\">\n(defn factorial [n]\n  (if (= 1 n)\n    n\n    (* n (factorial (- n 1)))))\n\n(factorial 4)\n  </code>\n</pre>\n<p>Now call the factorial function with some other natural number (whole number > 0) and see the results.</p>\n<p>For those of you who don’t know <code class=\"language-text\">Clojure(Script)</code>, this function basically says:</p>\n<ul>\n<li>define a function named <code class=\"language-text\">factorial</code></li>\n<li>let <code class=\"language-text\">n</code> be its argument</li>\n<li>if <code class=\"language-text\">n</code> equals 1, return <code class=\"language-text\">n</code></li>\n<li>otherwise return the multiplication of <code class=\"language-text\">n</code> with the <code class=\"language-text\">factorial</code> of (n - 1)</li>\n</ul>\n<p>Lisp in the browser. Embedded in this blog. No setup required. Excellent!</p>\n<p>But hang on, better things will follow soon.</p>\n<h2 id=\"clojure-is-designed-to-be-a-hosted-language\"><a href=\"#clojure-is-designed-to-be-a-hosted-language\" aria-label=\"clojure is designed to be a hosted language permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clojure is designed to be a hosted language</h2>\n<p>Why reinvent your own platform, your own runtime, your own garbage collector, your own ecosystem, when all you need is a decent language? <code class=\"language-text\">Clojure</code> is designed to be a hosted language. It runs on:</p>\n<ul>\n<li><a href=\"https://www.clojure.org/about/jvm_hosted\">The JVM</a></li>\n<li><a href=\"https://www.clojure.org/about/clojureclr\">The CLR</a></li>\n<li><a href=\"https://clojurescript.org\">Javascript engines</a></li>\n</ul>\n<p><code class=\"language-text\">Clojurescript</code> - a compiler for <code class=\"language-text\">Clojure</code> that emits javascript - will be the tool we use in this blog to visualise Bézier curves. We are going to manipulate a html canvas right from a klipse plugin.</p>\n<h2 id=\"bézier-in-clojurescript\"><a href=\"#b%C3%A9zier-in-clojurescript\" aria-label=\"bézier in clojurescript permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bézier in ClojureScript</h2>\n<p>In my <a href=\"https://040code.github.io/2017/07/01/bezier-in-clojure/\">previous post</a> I tried to explain how (simple) Bézier curves ‘work’. You might want to go there or scan the <a href=\"https://en.wikipedia.org/wiki/B%C3%A9zier_curve\">Wikipedia page on Bézier curves</a> if you have no clue what I’m talking about. Otherwise, let’s dive right in and try to play with Bézier curves directly on this page.</p>\n  <pre>\n    <code class=\"language-klipse\">\n;; Get a grip on the html canvas element I inserted on this page\n(def canvas (.getElementById js/document \"canvas-2d\"))\n(def ctx    (.getContext canvas \"2d\"))\n\n\n;; Draws a blue circle with radius `r` on the canvas on point [x y]\n(defn draw-point [x y]\n  (let [r 5] ;; radius\n    (set! (.-fillStyle ctx) \"blue\")\n    (.beginPath ctx)\n    (.arc ctx x y r 0 (* 2 Math/PI))\n    (.fill ctx)))\n\n\n;; Draws a red Bézier curve and its blue control points on the canvas\n(defn draw-bezier-curve [[x1 y1] [x2 y2] [x3 y3]]\n  ;; draw curve\n  (set! (.-strokeStyle ctx) \"red\")\n  (set! (.-lineWidth   ctx) 2)\n  (.beginPath ctx)\n  (.moveTo ctx x1 y1)\n  (.quadraticCurveTo ctx x2 y2 x3 y3)\n  (.stroke ctx)\n  (.closePath ctx)\n  ;; draw control points\n  (draw-point x1 y1)\n  (draw-point x2 y2)\n  (draw-point x3 y3))\n\n\n;; Center the *drawing* canvas within the *html* canvas and draw the curves\n;;\n;; Reason for centering: keep the coordinates simple AND\n;; see the complete shapes (not cropped at the edge of the html canvas)\n;; make the ratio 1 to see what I mean with 'cropped at the edge'\n;;\n(let [wc (.-width canvas)  ;; width of *html* canvas\n      hc (.-height canvas) ;; height of *html* canvas\n      ratio 0.9            ;; ratio of *html* canvas to use as *drawing* canvas\n      t  (/ (- 1 ratio) 2) ;; translation constant\n      w  (* ratio wc)      ;; width of *drawing* canvas\n      h  (* ratio hc)      ;; height of *drawing* canvas\n      x  (* 1/2 w)         ;; x val in the middle of 0 and w\n      y  (* 1/2 h)]        ;; y val in the middle of 0 and h\n\n  ;; clear *html* canvas\n  (.clearRect ctx 0 0 wc hc)\n\n  ;; Center the *drawing* canvas in the *html* canvas\n  (.save ctx)\n  (.translate ctx (* t wc) (* t hc))\n\n  ;; Draw a grey border around the *drawing* canvas\n  (set! (.-lineWidth ctx) 1)\n  (set! (.-strokeStyle ctx) \"grey\")\n  (.strokeRect ctx 0 0 w h)\n\n  ;; Draw main 'anchor' points\n  ;; This is what I meant with 'simple coordinates':\n  ;; (draw-point 0 0)\n  ;; (draw-point x y)\n  ;; (draw-point w h)\n\n  ;; Increasing ascending curve\n  (draw-bezier-curve [0 h] [w h] [w 0])\n\n  ;; Swoosh\n  ;; (draw-bezier-curve [0 y] [0 h] [w 0])\n\n  ;; normal curve\n  ;; (draw-bezier-curve [0 h] [x 0] [w h])\n\n  ;; my pulse after a useless meeting\n  ;; (draw-bezier-curve [0 y] [x y] [w y])\n\n  (.restore ctx))\n    </code>\n  </pre>\n<p><canvas id=\"canvas-2d\" width=\"600\" height=\"600\"></canvas></p>\n<script src=\"https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js?\"></script>\n<p>Before reading further you might want to experiment a bit by (un)commenting code and seeing the results. (Un)comment the different Bézier curves and different control points in the Klipse evaluator and see what happens.</p>\n<h2 id=\"explanation\"><a href=\"#explanation\" aria-label=\"explanation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Explanation</h2>\n<p>Scanning the code quickly without going into detail, this is what happens:</p>\n<ul>\n<li>Get a grip on the html canvas element</li>\n<li>\n<p>Define functions to:</p>\n<ul>\n<li>Draw (control) points</li>\n<li>Draw Bézier curves with 3 control points</li>\n</ul>\n</li>\n<li>Draw the actual curves and points</li>\n</ul>\n<p>Since <code class=\"language-text\">Clojure</code> is a hosted language, it must be able to access its host platform and libraries. <code class=\"language-text\">Clojure</code> and <code class=\"language-text\">ClojureScript</code> have good <a href=\"https://clojure.org/reference/java_interop\">interop</a> <a href=\"http://cljs.github.io/api/syntax/#dot\">documentation</a> so I won’t go into detail here, but we’re basically using these forms in this blog:</p>\n<ul>\n<li><code class=\"language-text\">js/document</code>       => the global document object</li>\n<li><code class=\"language-text\">(.beginPath ctx)</code>  => <code class=\"language-text\">ctx.beginPath()</code></li>\n<li><code class=\"language-text\">Math/PI</code>           => 3.141592653589793</li>\n<li><code class=\"language-text\">(.-lineWidth ctx)</code> => <code class=\"language-text\">ctx.lineWidth</code></li>\n</ul>\n<p>The last form is used for instance in <code class=\"language-text\">(set! (.-lineWidth ctx) 1)</code> and translates to <code class=\"language-text\">ctx.lineWidth = 1</code>. The more general syntax is <code class=\"language-text\">(set! var-symbol expr)</code>.</p>\n<p>The second form <code class=\"language-text\">(.beginPath ctx)</code> can also have arguments. The general syntax is <code class=\"language-text\">(.instanceMember instance args*)</code> in that case.</p>\n<p>Other than that it’s basic <code class=\"language-text\">Clojure</code> and <a href=\"https://www.w3schools.com/tags/ref_canvas.asp\">HTML Canvas functionality</a></p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>Thanks to the klipse plugin and a bit of preparation from my side, you can now play around with Bézier Curves in <code class=\"language-text\">ClojureScript</code> directly in this blog. I do realise this post is probably not a compelling case for using <code class=\"language-text\">ClojureScript</code>:</p>\n<ul>\n<li>Javascript “in the small” is not really the place where <code class=\"language-text\">ClojureScript</code> shines, especially when the largest part of that small program is javascript interop</li>\n<li><code class=\"language-text\">ClojureScript</code> fits large browser applications better, where you need sane state management, immutable datastructures, lazy sequences, and a fast,  stable and robust language</li>\n</ul>\n<p>I’m not interested in ‘religious’ discussions about technology A versus technology B. <code class=\"language-text\">Clojure</code> and <code class=\"language-text\">ClojureScript</code> are THE sane way forward for me, in my context. I hope to share the fun I’m experiencing with it. Goethe said it best:</p>\n<blockquote>\n<p>It is always better to say right out what you think without trying to prove anything much: for all our proofs are only variations of our opinions, and the contrary-minded listen neither to one nor the other.</p>\n</blockquote>\n<p>But with all this talk about language, we’re almost forgetting what it’s all about: building useful stuff and having a great time doing it.</p>\n<p>I hope you enjoyed experimenting with Bézier curves. The <a href=\"http://blog.klipse.tech\">Klipse Blog</a> has several great examples of using Klipse for ‘interactive programming’, for instance <a href=\"http://blog.klipse.tech/data/2017/03/17/data-driven-documents-google-charts.html\">to write data driven documents</a>.</p>\n<p>Thanks Niek for sharing the 040code repo with me. Please share your comments, suggestions and thoughts about this blog post on <a href=\"https://twitter.com/mmz_\">twitter.com/mmz_</a>. Thanks for reading and Happy Coding!</p>\n<h2 id=\"links\"><a href=\"#links\" aria-label=\"links permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links</h2>\n<ul>\n<li><a href=\"https://040code.github.io/2017/07/01/bezier-in-clojure/\">Bézier in Clojure - Part I</a></li>\n<li><a href=\"https://github.com/viebel/klipse\">Klipse plugin</a></li>\n<li><a href=\"http://blog.klipse.tech\">Klipse Blog</a></li>\n<li><a href=\"http://app.klipse.tech\">Klipse App in the browser</a></li>\n<li><a href=\"http://blog.klipse.tech/clojure/2016/03/17/klipse.html\">Explanation about the Klipse app</a></li>\n<li><a href=\"http://blog.klipse.tech/data/2017/03/17/data-driven-documents-google-charts.html\">Using Klipse for generating data driven charts</a></li>\n<li><a href=\"https://jsfiddle.net\">JSfiddle</a></li>\n<li><a href=\"http://cljs.github.io/api/syntax/#dot\">Javascript interop</a></li>\n<li><a href=\"https://clojure.org/reference/java_interop\">Java interop</a></li>\n<li><a href=\"https://www.w3schools.com/tags/ref_canvas.asp\">HTML Canvas functionality</a></li>\n</ul>","frontmatter":{"title":"Visualising Bézier Curves Part II","subtitle":"Experimenting with ClojureScript","date":"2017-07-12","slug":"2017/07/12/visualizing-bezier-curves-part-2","language":null,"tags":["clojure","clojurescript","bézier","functional","klipse","canvas"],"authors":["maarten"],"comments":null,"cover":{"publicURL":"/static/hendry_dunant_park-7544a1ecce84d50d573c6c2c3397a89c.jpg"},"coverLink":null,"coverDescription":null,"imageTw":{"publicURL":"/static/2017-07-12-visualizing-bezier-curves-part-2-tw-3f7cf220abe698bfd59a339561c8b4f0.png"},"imageFb":{"publicURL":"/static/2017-07-12-visualizing-bezier-curves-part-2-fb-ac0f6ed32802c312fa054c1befcf8e49.png"},"asciinema":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2017/07/12/visualizing-bezier-curves-part-2","previous":{"frontmatter":{"title":"Visualising Bézier Curves","slug":"2017/07/01/visualising-bezier-curves","type":"post","tags":["clojure","bézier","functional","incanter"],"authors":["maarten"]}},"next":{"frontmatter":{"title":"Full Stack Fest 2017","slug":"2017/09/05/full-stack-fest-2017","type":"post","tags":["iot","cloud","fullstack","microservices","security"],"authors":["jeroen","niek"]}}}}}