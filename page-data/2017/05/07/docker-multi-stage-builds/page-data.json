{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017/05/07/docker-multi-stage-builds","webpackCompilationHash":"5922713c92655645bc49","result":{"data":{"markdownRemark":{"id":"fd7b2e7a-8e02-5c70-9c54-cfe90fec03fc","excerpt":"The problem Building an application requires typically multiple steps. First compiling the application, next testing it and finally shipping…","html":"<h1 id=\"the-problem\"><a href=\"#the-problem\" aria-label=\"the problem permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem</h1>\n<p>Building an application requires typically multiple steps. First compiling the application, next testing it and finally shipping the artifact in a Docker image for execution. All these steps can be combined in one <code class=\"language-text\">Dockerfile</code>, but typically you end up with a Docker image that contains all kinds of tools that are not necessary for running the application.</p>\n<p>We could try to get rid of all unneeded files in the image after build, but a more useful approach is to separate Docker images for building and running the application. However, this approach requires two separate Dockerfiles that needs to be maintained.</p>\n<p>Let’s have a look on a <a href=\"https://github.com/040code/blog_docker-mulit-stage-build.git\">example</a> for a simple Java micro service. The micro services require the JDK and Gradle to build. The JDK needs to be installed before the build and Gradle will be download by the build itself. We can build the micro service in the following way.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git clone https://github.com/040code/blog_docker-mulit-stage-build.git\ncd notes-service\ndocker run -it --rm -v $(pwd):/build -w /build openjdk:8u121-jdk-alpine ./gradlew build</code></pre></div>\n<p>Now the artifact is available, we can create a Docker runtime image. The application only needs the Java Runtime (JRE) to run. We create a <code class=\"language-text\">Dockerfile</code> based JRE alpine image and add our application.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># file: Dockerfile (git checkout step-00)\nFROM openjdk:8u121-jre-alpine\nCOPY build/libs/notes-service.jar /app/notes-service.jar\n\nEXPOSE 8080\nCMD java -jar /app/notes-service.jar</code></pre></div>\n<p>Next, we build the production image as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker build -t notes-service:00 .</code></pre></div>\n<p>Now we have created a clean Docker images that only containes the needed libraries to run the application. But would it not be nice if we can do this more straightforward? For example, in one Docker build.</p>\n<h1 id=\"moving-on-to-a-multi-stage-build\"><a href=\"#moving-on-to-a-multi-stage-build\" aria-label=\"moving on to a multi stage build permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Moving on to a multi stage build</h1>\n<p>Docker 17.05.x brings a new feature; it is now possible to define a <a href=\"https://docs.docker.com/engine/userguide/eng-image/multistage-build/\">multi stage builds</a> in one Dockerfile. The Dockerfile can contain multiple FROM lines and each stage starts with a new FROM line and a fresh context. You can copy artifacts from stage to stage.</p>\n<a href=\"#\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.758880516684606%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACsUlEQVQozz2STU8TURiFZ+fanUt/gRs3LkyMP8KVv0DDwoRoWKEoG6JWNGqEmKBEFBGISqEBi1aQAgGE8jH9LoVpO51OmbYUWvpBH99OI4s3997c+557znmPkiymUE0Nv7mPdpgkmkugZlr73byUnP1yv19Isq7vEbU0qg2D8qnByVllzvZKTJpcoQiTgTCL+zFmwhGpKMuJOD8iMb77I2ymmx+kCFlJ9JJBnSw1qToH9lqup6k0WqBKvpJmr2iQLGXI1nKE8waRXIpEUSeY1YjlE9Jk0Gg2VhMYBwHMQhQ9GyBpqmQLMU4F2GYozBUtvc3Siou1DTeumc8EQosclfY4PtEEJENNHpWEQZONZqi8HXzBh899jE0M2mv/u142w0tUMVsM46ktRr4O8Gm8Xx4NMOkeZtozinkYBgoC2pRlSkOWTC7Cz/nveBaczC9N8dPrxLfmxpoZo1zThWEGJSv0d8LLuD2zTDinGB7+gueXh0BQZXt7A1X1kbF2bd+aDErSWK7rHFdTMpg0hZMosciC7WFFPlYa5MSXMM+7J3jc+YeHd708aJ+n7eYYVy/c59K5Dvod48LQEIZ75I4TFCstsFLVtD93fn2Db31UlFgo/tA0vY+u0feknZ77C3R3+HjctUXHbTdXzj/gonKPZ13DIv+Aw3KKo4qOkYtTaqSJ7/q5dX2Qd44hxobaKJQ0GYq+infuPat/f/HpwxKvHIu8fuqj846bG5cd9NwdIRT0236eCoOGFOTtfTOL6vJHFid7cE+/FNkiuS4XNZHdzNOpTLUo052dc+J0feP3HxeB+AKrW7NsBbzsSAK2g168K9OE42sCnidhbLK+MSV2BO3BKa2Ep23DK5L4ZkgNK4h1FBNpITRdJWUGSB8E7bNhhQRkB6u4KwAZexhVseN/sP8Bc58C1cyyjvgAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <picture>\n        <source srcset=\"/static/9f19fe775a09640a4724e3e5fd31b87b/cc182/docker-multi-stages-build.webp 148w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/f7e40/docker-multi-stages-build.webp 295w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/1a2f4/docker-multi-stages-build.webp 590w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/4837b/docker-multi-stages-build.webp 885w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/2f819/docker-multi-stages-build.webp 1180w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/2cc55/docker-multi-stages-build.webp 1858w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/webp\">\n        <source srcset=\"/static/9f19fe775a09640a4724e3e5fd31b87b/cf440/docker-multi-stages-build.png 148w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/d2d38/docker-multi-stages-build.png 295w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/b9e4f/docker-multi-stages-build.png 590w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/f9b6a/docker-multi-stages-build.png 885w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/2d849/docker-multi-stages-build.png 1180w,\n/static/9f19fe775a09640a4724e3e5fd31b87b/bb319/docker-multi-stages-build.png 1858w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/png\">\n        <img class=\"gatsby-resp-image-image\" src=\"/static/9f19fe775a09640a4724e3e5fd31b87b/b9e4f/docker-multi-stages-build.png\" alt=\"docker-multi-stages-build\" title=\"docker-multi-stages-build\" loading=\"lazy\">\n      </picture>\n    </span>\n</a>\n<p>Now it is time to have a second look on the same example. Instead of passing the build arguments and mounting our sources, we will build our software using a single Dockerfile.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># file: Dockerfile (git checkout step-01)\nFROM openjdk:8u121-jdk-alpine AS build\n\nWORKDIR /build-env\nADD . /build-env\nRUN ./gradlew build\n\nCMD java -jar /build-env/build/notes-service.jar</code></pre></div>\n<p>And build it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker build -t notes-service:01 .</code></pre></div>\n<p>Nothing new here, we are now able to build our software in a container and ship an image, but the image contains all kinds of build stuff that we do not want in a runtime image. So, the next step is to solve this problem by getting rid of all the unwanted build tools.</p>\n<p>We update the <code class=\"language-text\">Dockerfile</code> and make a few modifications.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># file: Dockerfile (git checkout step-02)\nFROM openjdk:8u121-jdk-alpine AS build                                               # (1)\n\nWORKDIR /build-env\nADD . /build-env\nRUN ./gradlew build\n\nFROM openjdk:8u121-jre-alpine                                                        # (2)\nCOPY --from=build /build-env/build/libs/notes-service.jar /app/notes-service.jar     # (3)\n\nEXPOSE 8080\nCMD java -jar /app/notes-service.jar</code></pre></div>\n<p>In the <code class=\"language-text\">Dockerfile</code> above we marked the first stage (1) as <em>build</em> to refer later, if not specifying a name you can refer to the stage as 0. Next (2), we add the second stage which specifies the base image that we need to run our application. Finally (3), we copy the results from the build stage to the image for executing.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker build -t notes-service:02 .</code></pre></div>\n<p>And now we can run via the following docker run command.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -it --rm -p 8080 notes-service:2</code></pre></div>\n<p>Inspection of the tree images build will show that version 0 and 2 are equal in size, version 1 that contains all the build files and the JDK is almost three times bigger.</p>\n<h1 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h1>\n<p>Docker’s new multi layer build feature can be quite useful when build pipeline without parallel builds will suite your needs. In that case, you can reduce your build to a single image. For projects that requires a more complex multi stage build, including parallel builds, this new Docker feature will not provide an added value.</p>","frontmatter":{"title":"Docker Multi Stage Builds","subtitle":"Building and shipping in one Docker build","date":"2017-05-07","slug":"2017/05/07/docker-multi-stage-builds","language":null,"tags":["docker"],"authors":["niek"],"comments":null,"cover":{"publicURL":"/static/containers-strijp-s-865e0fd570fd27aef20a38112634d3f2.png"},"coverLink":null,"coverDescription":null,"imageTw":{"publicURL":"/static/2017-05-07-docker-multi-stage-builds-tw-3ae3a359585ebd85ae966ae67d33d986.png"},"imageFb":{"publicURL":"/static/2017-05-07-docker-multi-stage-builds-fb-51a31d569efb9835b0dbe7cf6cc50a09.png"},"asciinema":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2017/05/07/docker-multi-stage-builds","previous":{"frontmatter":{"title":"Periodic builds in GitLab","slug":"2017/04/21/gitlab-perodic-build","type":"post","tags":["gitlab","docker"],"authors":["niek"]}},"next":{"frontmatter":{"title":"GraphQL","slug":"2017/05/20/graphql","type":"post","tags":["graphql"],"authors":["niek"]}}}}}