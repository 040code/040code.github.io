{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018/02/14/service-discovery-on-aws","webpackCompilationHash":"e438c96074ba29909476","result":{"data":{"markdownRemark":{"id":"6cf09012-7fdd-50d0-adac-968e8527994d","excerpt":"Last year I wrote a post how to implement service discovery for Spring Boot applications running in Docker containers on AWS ECS. At thatâ€¦","html":"<p>Last year I wrote a <a href=\"/2017/04/20/discovery-agent/\">post</a> how to implement service discovery for Spring Boot applications running in Docker containers on AWS ECS. At that time the Amazon ECS agent does not have support to discover the docker exposed ports inside the container. In November 2017 Amazon released a feature in the <a href=\"https://github.com/aws/amazon-ecs-agent/releases/tag/v1.15.0\">ECS agent 1.15</a> to retrieve container meta data in the container. This feature makes the discovery agent obsolete.</p>\n<h3 id=\"the-problem\"><a href=\"#the-problem\" aria-label=\"the problem permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem</h3>\n<p>Looking back to the last years problem. A Spring service running in a container needs its external ip address and port to register to Eureka for service discovery. A service running in a container does not know the external exposed port and docker does not support a way to obtain the port mapping. We could inject the ip address but for the port that would not work. Since the port is unknown at start time. Of course, this in only valid when using random ports. But fixing the port can eventually cause port conflicts. Besides that, you are not able to scale the container on the same host. Therefore, it makes sense to use automatic port assignment.</p>\n<p>At that time I have solved this problem by adding an agent that can be called via a REST interface to lookup the exposed port based on the container id and internal port. The agent returns the external port, and the service can use this information to register itself to Eureka. This approach worked well but since the ECS agent is now shipped with a feature to retrieve the meta data we do not need longer an extra agent anymore.</p>\n<a href=\"#\">\n    <img src=\"./ecs1.png\" height=\"80%\" width=\"80%\" alt=\"ECS\">\n</a>\n<h3 id=\"solution\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h3>\n<p>The approach to register the container to the discovery service remains the same. During container startup, the start script obtains the external ip address, and docker exposed port. The discovered information will be passed to the Spring Boot application using environment variables. At application start the Spring service discovery client uses the environment variables to register the application to Eureka.</p>\n<a href=\"#\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 30.92885375494071%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsSAAALEgHS3X78AAAA8ElEQVQY03VPy04CMRSdf8SdCcS48Rv8BcKexWwMaiZxzwYiwcgWCBtI2Ii8JoGAdKbtdHoftoMCMfHmLHraex4NdtJWHtd30UoZy8xEfBxAf3oZplfhvBTO629bR6O+KIWLcmN9/bCsPMVBItWX1CJRIkmJsTlR1fa29rprjRPvxYTIAM70x9XdAJCnRMExTRm0boV5NJNRL653Vr3pvlj1r05/OSfqxb4g8UxT+KGfl1n3QHmuAW0GlDMb5Aw4pzOUvRBD4TTYm9v3xU33876/iYWWUmIRQegXiM8oKv6K/xRz/xGpNi6a2MHH/lP7GzauUK6sx1oiAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <picture>\n        <source srcset=\"/static/25e184fa827b834f292338cc7a813f29/cc182/sequence.webp 148w,\n/static/25e184fa827b834f292338cc7a813f29/f7e40/sequence.webp 295w,\n/static/25e184fa827b834f292338cc7a813f29/1a2f4/sequence.webp 590w,\n/static/25e184fa827b834f292338cc7a813f29/4837b/sequence.webp 885w,\n/static/25e184fa827b834f292338cc7a813f29/5a7f1/sequence.webp 1012w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/webp\">\n        <source srcset=\"/static/25e184fa827b834f292338cc7a813f29/cf440/sequence.png 148w,\n/static/25e184fa827b834f292338cc7a813f29/d2d38/sequence.png 295w,\n/static/25e184fa827b834f292338cc7a813f29/b9e4f/sequence.png 590w,\n/static/25e184fa827b834f292338cc7a813f29/f9b6a/sequence.png 885w,\n/static/25e184fa827b834f292338cc7a813f29/37b61/sequence.png 1012w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/png\">\n        <img class=\"gatsby-resp-image-image\" src=\"/static/25e184fa827b834f292338cc7a813f29/b9e4f/sequence.png\" alt=\"Sequence Diagram\" title=\"Sequence Diagram\" loading=\"lazy\">\n      </picture>\n    </span>\n</a>\n<p>Before we are able retrieve information about the container (in the container) we need to enable the feature on the ECS instance. For more details about this feature see the <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container-metadata.html\">Amazon documentation</a>. To enable the meta data in the container you need to set <code class=\"language-text\">ECS_ENABLE_CONTAINER_METADATA</code> to <code class=\"language-text\">true</code>. This can be easily done by adding the line below the user data script.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">echo ECS_ENABLE_CONTAINER_METADATA=true &gt;&gt; /etc/ecs/ecs.config</code></pre></div>\n<p>Now each created container by ECS on the EC2 instances will have the meta data available in the file assigned to the environment variable <code class=\"language-text\">ECS_CONTAINER_METADATA_FILE</code>. An example of the meta data looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  &quot;Cluster&quot;: &quot;ecs-cluster&quot;,\n  &quot;ContainerInstanceARN&quot;: &quot;arn:aws:ecs:eu-west-1:1234445678:some-id&quot;,\n  &quot;TaskARN&quot;: &quot;arn:aws:ecs:eu-west-1:1234445678:some-other-id&quot;,\n  &quot;ContainerID&quot;: &quot;container-id&quot;,\n  &quot;ContainerName&quot;: &quot;my-service&quot;,\n  &quot;DockerContainerName&quot;: &quot;docker-container-name&quot;,\n  &quot;ImageID&quot;: &quot;image-id&quot;,\n  &quot;ImageName&quot;: &quot;docker-image&quot;,\n  &quot;PortMappings&quot;: [\n    {\n      &quot;ContainerPort&quot;: 8080,\n      &quot;HostPort&quot;: 320001,\n      &quot;BindIp&quot;: &quot;0.0.0.0&quot;,\n      &quot;Protocol&quot;: &quot;tcp&quot;\n    }\n  ],\n  &quot;Networks&quot;: [\n    {\n      &quot;NetworkMode&quot;: &quot;default&quot;,\n      &quot;IPv4Addresses&quot;: [\n        &quot;172.17.0.2&quot;\n      ]\n    }\n  ],\n  &quot;MetadataFileStatus&quot;: &quot;READY&quot;\n}</code></pre></div>\n<p>Next we fetch the ip address and port during container start. The ip address we still get through the standard amazon info endpoint.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export EUREKA_INSTANCE_IP_ADDRESS=$(curl --retry 5 --connect-timeout 3 -s 169.254.169.254/latest/meta-data/local-ipv4)</code></pre></div>\n<p>We extract the port mapping from the metadata using <code class=\"language-text\">jq</code>. We assume the service will run in the container on port 8080. Otherwise you can make this configurable as well.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export EUREKE_INSTANCE_NON_SECURE_PORT=$(cat ${ECS_CONTAINER_METADATA_FILE} | jq -c -r &quot;.PortMappings[] | select(.ContainerPort == 8080) | .HostPort&quot;)</code></pre></div>\n<p>By using the Spring properties as environment variables, we can inject the information to the Spring application. Alternatively, you can use other names and assign the values in the <code class=\"language-text\">application.yml</code> file, see the example below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eureka:\n  instance:\n    preferIpAddress: true\n    ip-address: ${EXTERNAL_IP}\n    non-secure-port: ${EXTERNAL_PORT}</code></pre></div>\n<p>With this approach the discovery agent becomes obsolete and we can retrieve the information for discovery through standard Amazon features. The example I have described in this post is just one way to implement service discovery in ECS, many alternatives are available.</p>","frontmatter":{"title":"Service Discovery on AWS","subtitle":"Enabling discovery for Spring Cloud on AWS ECS","date":"2018-02-14","slug":"2018/02/14/service-discovery-on-aws","language":null,"tags":["aws","spring","docker"],"authors":["niek"],"comments":null,"cover":{"publicURL":"/static/holstlaan-dommel-d5013c3a62451a107813bc5bed7d96ea.jpg"},"coverLink":"https://goo.gl/maps/NSJUxqvPzc32","coverDescription":"Dommel / Professor Holstlaan","imageTw":{"publicURL":"/static/2018-02-14-service-discovery-on-aws-tw-672a03726baa5dbeea7061a814101dd9.png"},"imageFb":{"publicURL":"/static/2018-02-14-service-discovery-on-aws-fb-acf3ef09c68c9029cf39b9e064a08436.png"},"asciinema":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2018/02/14/service-discovery-on-aws","previous":{"frontmatter":{"title":"MicroHack Fargate","slug":"2018/01/30/microhack-fargate","type":"post","tags":["aws","terraform","docker","microhack"],"authors":["niek"]}},"next":{"frontmatter":{"title":"Verlet Integration","slug":"2018/03/04/verlet-integration","type":"post","tags":["clojure","functional"],"authors":["maarten"]}}}}}